Graph generation and Simulation
Generation:
 Naturally occurring graphs show some patterns regularly which collectively characterize them
separately. These include:
• Power laws
• Small Diameters
• Community effect (Clustering)
Social networks form a power distribution, which simply means that the degree distribution of
the graph follows power law. The significance of a power law distribution lies in the fact that it
decays only polynomialy quickly size of the input increases instead of the exponential decay in
the Gaussian distribution.
Small diameter is the minimum number of hops in which some fraction (say, 90%) of all
connected pairs of nodes can reach each other. Thirdly, A community is generally considered to
be a set of nodes where each node is closer to the other nodes within the community than to
nodes outside it.
We have tried to simulate a social network as a scale free graph by incorporating the properties
of scale free networks, namely the Power law distribution followed by them (Barabasi and
Albert, 1999) [10] and the community effect also called the clustering (Holme and Kim, 2002)
[9].
Algorithm for graph creation:-
1. The user needs to input the number of degrees for which the graph is to be created that is
node_count and a minimum degree of a node that is 'm'.
2. A manual creation of three nodes.
3. The graph follows the preferential attachment by randomly selecting a node and adds
edge to it.
4. In order to maintain the clustering coefficient a node will randomly select the nodes from
its neighborhood to increase its degree.
Assumptions:
1. We have considered a basic degree of every node in a network, termed as 'm', that simply
means that any node in the graph will have at least m degree.
2. We have taken the User Agent String (UAS) as a variable. For simulation purposes we have
chosen a set of variables from which we are randomly assigning one to every node of the graph.
3. We are generating first three nodes manually, so as to avoid the generation of disconnected
components in the graph.
4. We have assumed that the degree of a node (the total no of connections) is a factor of
influence in its neighborhood.
Simulation and Analysis:
We tried to simulate the model on a 10,000 node graph and simulated it for three different
choosing policies firstly choosing UAS from a random neighbor in the neighborhood, secondly
choosing UAS from a neighbor with lowest degree in the whole neighborhood and thirdly
choosing UAS from neighbor of highest degree in the neighborhood.
We have taken all the three above scenarios and simulated them to see how these choosing
policies affect the next state of the neighborhood.
Algorithm used simulation and analysis:-
1. After generation of the algorithm three text file are maintained
a) First named “neighbor.txt” contains list of all the nodes and the nodes connected
nodes to them.
b) Second named “degree_all.txt” that has degree of all the nodes in the graph with the
node number.
c) Third named as “variable.txt” that has randomly selected variable for each node from
a set of alphabets.
2. The list of neighbors in sorted by Quick Sort so it is easy to analyze.
3. Repeat the steps for three scenario :
a) The variable of the node which has maximum degree will be selected.
b) The variable of the node which has minimum degree will be selected.
c) Randomly select the variable from its neighbors will be selected.
4. Enter the node number for which you want to check that is the neighbors of that node
select which variable.
5. The output is stored in a log file with fields
a) The node number and its degree
b) The variable selected by its neighbors with the neighbor node number.
c) Counts are maintained to count the number of variable selected.
Outcomes/Results:
a. If the variables are accessed regularly after a fixed period of time and no user remains online
for the whole day than, then the graph never gets stability. (A graph is stable if all the nodes have
the same variables across the network).
b. We can also choose a variable for each node from one of its random neighbour, similarly we
can also choose variable from the lowest ranking (degree) neighbour, but the anonymity
generated in these cases is certainly lower in the sense that the choice of variables in a
neighborhood would be scattered, resulting in a unique fingerprint of small groups of nodes. On
the other hand if we will choose the variable from a neighbor of highest degree and use it then
there will be a large set of nodes with same variable fingerprint, hence more anonymity. Another
advantage in this scheme is that the anonymity set remains for a longer period of time.
In the process of generation of the graph some files are generated by the code, namely:
1. 'neighbors.txt'- showing the neighbours of a node, eg. first line has neighbours of 0th node
 in [ ], then 1, then 2 node's...and so on.
2. 'variable.txt' - showing the variable assigned to each node from a set of variables, eg. First
 line is 0's variable, then 1's, 2's,.....and so on.
3. 'deg_all.txt'- shows the node no. followed by its degree in the graph in a line.
4. 'degree.txt'- temporary file used in course of the code to hold specific nodes with their degree
5. 'log.txt' - file showing the selected variables by the neighbors of a passed node. The file is
in append mode so keeps on adding new entries every time the programme is run. 
